<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- 
This manual is for GNU Java Training Wheels (version 2.0,
25 July 2016), which is a system for making it easier for novices
to learn to program in the Java language.

Copyright (C) 2016 Davin Pearson.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with no
Invariant Sections, with no Front-Cover Texts, and with no Back-Cover
Texts.  A copy of the license is included in the section entitled
"GNU Free Documentation License". -->
<!-- Created by GNU Texinfo 5.2, http://www.gnu.org/software/texinfo/ -->
<head>
<title>GNU Java Training Wheels 2.0: J.T.W. Proof of concept #1 A superfor macro</title>

<meta name="description" content="GNU Java Training Wheels 2.0: J.T.W. Proof of concept #1 A superfor macro">
<meta name="keywords" content="GNU Java Training Wheels 2.0: J.T.W. Proof of concept #1 A superfor macro">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link href="index.html#Top" rel="start" title="Top">
<link href="Index.html#Index" rel="index" title="Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="index.html#Top" rel="up" title="Top">
<link href="J_002eT_002eW_002e-Proof-of-concept-_00232-file-inclusion.html#J_002eT_002eW_002e-Proof-of-concept-_00232-file-inclusion" rel="next" title="J.T.W. Proof of concept #2 file inclusion">
<link href="About-GNU-Java-Training-Wheels.html#About-GNU-Java-Training-Wheels" rel="prev" title="About GNU Java Training Wheels">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.smallquotation {font-size: smaller}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.indentedblock {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
div.smalldisplay {margin-left: 3.2em}
div.smallexample {margin-left: 3.2em}
div.smallindentedblock {margin-left: 3.2em; font-size: smaller}
div.smalllisp {margin-left: 3.2em}
kbd {font-style:oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: inherit; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: inherit; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.nocodebreak {white-space:nowrap}
span.nolinebreak {white-space:nowrap}
span.roman {font-family:serif; font-weight:normal}
span.sansserif {font-family:sans-serif; font-weight:normal}
ul.no-bullet {list-style: none}
-->
</style>
<link rel="stylesheet" type="text/css" href="/software/gnulib/manual.css">


</head>

<body lang="en" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">
<a name="J_002eT_002eW_002e-Proof-of-concept-_00231-A-superfor-macro"></a>
<div class="header">
<p>
Next: <a href="J_002eT_002eW_002e-Proof-of-concept-_00232-file-inclusion.html#J_002eT_002eW_002e-Proof-of-concept-_00232-file-inclusion" accesskey="n" rel="next">J.T.W. Proof of concept #2 file inclusion</a>, Previous: <a href="About-GNU-Java-Training-Wheels.html#About-GNU-Java-Training-Wheels" accesskey="p" rel="prev">About GNU Java Training Wheels</a>, Up: <a href="index.html#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html#Index" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<a name="J_002eT_002eW_002e-Proof-of-concept-_00231-A-superfor-macro-1"></a>
<h2 class="chapter">2 J.T.W. Proof of concept #1 A superfor macro</h2>

<a name="index-superfor-looping-construct"></a>


<p>A proof of concept for the J.T.W. preprocessor is the superfor macro,
which is an enhanced BASIC-style for loop.  Here is how to invoke the
superfor macro in your *.jtw file:
</p>
<div class="example">
<pre class="example">beginMain
&nbsp;&nbsp;&nbsp; superfor (var int i = 0 to 10)
&nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.println(&quot;i=&quot; + i);
&nbsp;&nbsp;&nbsp; end
endMain
</pre></div>

<p>The above code results in the following printout:
</p>
<div class="example">
<pre class="example">i=0
i=1
i=2
i=3
i=4
i=5
i=6
i=7
i=8
i=9
i=10
</pre></div>

<p>The step size argument is optional, here is an example with an
explicit step size announced:
</p>
<div class="example">
<pre class="example">beginMain
&nbsp;&nbsp;&nbsp; superfor (var int i = 0 to 10 step 2)
&nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.println(&quot;i=&quot; + i);
&nbsp;&nbsp;&nbsp; end
endMain
</pre></div>

<p>The above code results in the following printout:
</p>
<div class="example">
<pre class="example">i=0
i=2
i=4
i=6
i=8
i=10
</pre></div>

<p>If the downto keyword is given instead of the to keyword then the
loop will count downwards from the first given number to the second,
even if a postive step size is given.  Here is an example with a
negative step size:
</p>
<div class="example">
<pre class="example">beginMain
&nbsp;&nbsp;&nbsp; superfor (var int i = 10 downto 0 step 2)
&nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.println(&quot;i=&quot; + i);
&nbsp;&nbsp;&nbsp; end
endMain
</pre></div>

<p>The above code results in the following printout:
</p>
<div class="example">
<pre class="example">i=10
i=8
i=6
i=4
i=2
i=0
</pre></div>

<p>Note that the specification of the superfor macro doesn&rsquo;t need
constants for the values of start, stop and step-size.
They can be any variable or more generally any Java expression, and
those expressions will be evaluated only once, should your code have
side effects, i.e. changes the value of a variable in your code.  See
the following example.  The expression ++y has the side effect of
incrementing the value of y before returning the value of y:
</p>
<div class="example">
<pre class="example">beginMain
&nbsp;&nbsp;&nbsp; var int x = 20;
&nbsp;&nbsp;&nbsp; var int y = 15;
&nbsp;&nbsp;&nbsp; superfor (var int i = x to (2 * ++y))
&nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.println(&quot;i=&quot; + i);
&nbsp;&nbsp;&nbsp; end
endMain
</pre></div>

<p>The above code results in the following printout:
</p>
<div class="example">
<pre class="example">i=20
i=21
i=22
i=23
i=24
i=25
i=26
i=27
i=28
i=29
i=30
i=31
i=32
</pre></div>

<a name="Elisp-source-code-for-the-superfor-macro"></a>
<h3 class="section">2.1 Elisp source code for the superfor macro</h3>

<p>The following code belongs in the file
~/jtw/jtw-build-jtw.el which in itself is too
large for inclusion in this manual.  You can find this code by
visiting <a href="Tutorial-1-Your-first-program.html#J_002eT_002eW_002e-tarball">J.T.W. tarball</a>.  Alternatively, you can study this
fragment of the file ~/jtw/jtw-build-jtw.el which deals
with the superfor macro.  In the listing that follows,
*pp-namespace* stores a string containing a long arbitrary name to
prevent accidental aliasing of the include directives with rest of the
comments code.
</p>

<div class="example">
<pre class="example">(let (p1 p2 str form type variable T var start stop step-size step-size-2
             this_start this_stop this_step this_step_size file line p-prior
             beg0 end0)
      (setq strobe nil)
      (checkpoint &quot;2&quot;)
      (save-excursion
        (goto-char (point-min))
        (setq *superfor* 0)
        (while (re-search-forward &quot;\\&lt;superfor\\&gt;&quot; nil t)
          (setq beg0 (match-beginning 0))
          (setq end0 (match-end 0))
          ;;(checkpoint &quot;sitting for 1 seconds...&quot;)
          (font-lock-fontify-buffer)
          ;;(sit-for 1)
          (when (save-excursion
                  (save-match-data
                    (re-search-forward &quot;(&quot; (point-at-eol) t)
                    (forward-char -1)
                    (re-search-forward &quot;\\&lt;var\\&gt;&quot; nil t)
                    (not (warn--inside-comment-or-string))))
            ;;(error &quot;Smelly cat&quot;)
            (setq *current-buffer* (current-buffer))
            ;;(switch-to-buffer *current-buffer*)
            (setq p1 beg0)
            (assert (save-match-data
                      (looking-at &quot; \t\r\n*(&quot;)))
            (setq p2 (save-excursion
                       (forward-sexp 1)
                       (point)))
            (setq str (buffer-substring-no-properties end0 p2))
            ;;(checkpoint &quot;str=%s&quot; str)
            (setq form (read-str str))
            ;;(checkpoint &quot;form=%s&quot; form)
            ;;(debug &quot;form&quot;)
            (assert (consp form))
            (message &quot;*** form=%s&quot; form)
            ;;(error &quot;Rolling Stones plays Cuba&quot;)
            (delete-region p1 p2)
            (incf *superfor*)
            (setq this (format &quot;superfor_%d_&quot; *superfor*))
            (when (not (eq (nth 0 form) 'var))
              (warn--log-message &quot;Error 35: Keyword var missing from superfor construct&quot;)
              (when (and (not (eq (nth 1 form) 'char))
                         (not (eq (nth 1 form) 'short))
                         (not (eq (nth 1 form) 'int))
                         (not (eq (nth 1 form) 'long))
                         (not (eq (nth 1 form) 'float))
                         (not (eq (nth 1 form) 'double)))
                (warn--log-message (concat
                                    &quot;Error 37:#1 argument type to superfor macro must be&quot;
                                    &quot; one of char/short/int/long/float/double&quot;))))
            (when (eq (nth 0 form) 'var)
              (if (and (not (eq (nth 1 form) 'char))
                       (not (eq (nth 1 form) 'short))
                       (not (eq (nth 1 form) 'int))
                       (not (eq (nth 1 form) 'long))
                       (not (eq (nth 1 form) 'float))
                       (not (eq (nth 1 form) 'double)))
                  (warn--log-message (concat
                                      &quot;Error 37:#2 argument type to superfor macro must be&quot;
                                      &quot; one of char/short/int/long/float/double&quot;)))
              (progn
                ;;(debug &quot;Radiohead: Let Down&quot;)
                ;; (setq form '(var int i=0 to stop))
                ;; (setq form '(var int i =0 to stop))
                ;; (setq form '(var int i = 0 to stop))
                (setq type     (nth 1 form))
                (setq T        (prin1-to-string type))
                (setq variable (prin1-to-string (nth 2 form)))
                (if (string-match &quot;=&quot; variable)
                    (progn
                      (setq pre-red-str--variable (substring variable 0 (match-beginning 0)))
                      ;;(string-match &quot;=&quot; variable-equals)
                      (setq pre-red-str--start    (substring variable (match-end 0)))
                      ;;(debug &quot;Radiohead: Fitter Happier&quot;)
                      ;;(debug &quot;Jean Jarre: Equinoxe Part III&quot;)
                      (setq variable (and (not (string= &quot;&quot; pre-red-str--variable))
                                          (prin1-to-string (read-str pre-red-str--variable))))
                      (setq start (and (not (string= &quot;&quot; pre-red-str--start))
                                       (prin1-to-string (read-str pre-red-str--start))))
                      (cond
                       ((eq (nth 3 form) nil)
                        (setq start (concat start &quot;()&quot;))
                        (setq strobe t)
                        (debug &quot;Queen: One Vision&quot;)
                        (cond
                         ((eq (nth 4 form) 'to)
                          (setq to 'to))
                         ((eq (nth 4 form) 'downto)
                          (setq to 'downto))
                         (t
                          (debug &quot;Pretenders: Space Invader&quot;)))
                        (setq stop (prin1-to-string (nth 5 form)))
                        (cond
                         ((and (eq (nth 6 form) nil) (&gt; (length form) 6))
                          (setq stop (concat stop &quot;()&quot;))
                          ;;(debug &quot;The Pretenders: Kid&quot;)
                          (if (eq (nth 7 form) 'step)
                              (setq step-size (nth 8 form))))
                         ((string-match &quot;(&quot; (prin1-to-string (nth 6 form)))
                          (setq stop (concat stop (and (nth 6 form) (prin1-to-string (nth 6 form)))))
                          (if (eq (nth 7 form) 'step)
                              (setq step-size (nth 8 form))))
                         ((eq (nth 6 form) 'step)
                          (debug &quot;Pretenders: Private Life&quot;)
                          (setq step-size (nth 7 form)))
                         (t
                          ;;(debug &quot;Queen: It's a Kind of Magic&quot;)
                          )
                         ) ;; end COND!
                        (if strobe (debug &quot;Queen: One Year of Love&quot;))
                        )
                       ((string-match &quot;(&quot; (prin1-to-string (nth 3 form)))
                        ;;(debug &quot;Public Enemy: Letter to the New York Post&quot;)
                        (setq start (and (nth 3 form) (concat start (prin1-to-string (nth 3 form)))))
                        (cond
                         ((eq (nth 4 form) 'to)
                          (setq to 'to))
                         ((eq (nth 4 form) 'downto)
                          (setq to 'downto))
                         (t
                          (debug &quot;Elvis: King Creole&quot;)))
                        (setq stop (prin1-to-string (nth 5 form)))
                        (cond
                         ((and (eq (nth 6 form) nil) (&gt; (length form) 6))
                          (setq stop (concat stop &quot;()&quot;))
                          ;;(debug &quot;The Pretenders: Kid&quot;)
                          (if (eq (nth 7 form) 'step)
                              (setq step-size (nth 8 form))))
                         ;; ------------------------------------------
                         ((string-match &quot;(&quot; (prin1-to-string (nth 6 form)))
                          (setq stop (concat stop (prin1-to-string (nth 6 form))))
                          (if (eq (nth 7 form) 'step)
                              (setq step-size (nth 8 form))))
                         ;; ------------------------------------------
                         ((eq (nth 6 form) 'step)
                          (debug &quot;Pretenders: Private Life&quot;)
                          (setq step-size (nth 7 form)))
                         (t
                          ;;(debug &quot;Queen: It's a Kind of Magic&quot;)
                          )
                         )
                        ((eq (nth 3 form) 'to)
                         (setq to 'to)
                         (setq stop (nth 4 form))
                         (if (eq (nth 5 form) 'step)
                             (setq step-size (nth 6 form))
                           )
                         ;;(debug &quot;aaa&quot;)
                         )
                        ((eq (nth 3 form) 'downto)
                         (setq to 'downto)
                         (setq stop (nth 4 form))
                         (if (eq (nth 5 form) 'step)
                             (setq step-size (nth 6 form))
                           )
                         (debug &quot;bbb&quot;)
                         )
                        (t
                         (debug &quot;Dire Straits: The Bug&quot;)))
                       )
                      ;;(debug &quot;Bach's Mass in B Minor: Et in terra pax&quot;)
                      )
                  (if (eq (nth 3 form) '=)
                      (setq start (and (nth 4 form) (prin1-to-string (nth 4 form))))
                    (setq   start (and (nth 3 form) (prin1-to-string (nth 3 form))))
                    )) ;; end if!
                ;;(debug &quot;Bach's Mass in B Minor: Kyrie eleison&quot;)
                (cond
                 ((eq (nth 3 form) 'to)
                  (setq to 'to)
                  (setq stop (prin1-to-string (nth 4 form)))
                  (if (and (eq (nth 5 form) nil) (&gt; (length form) 5))
                      (setq stop (concat stop &quot;()&quot;))
                    (if (string-match &quot;(&quot; (prin1-to-string (nth 5 form)))
                        (setq stop (concat stop (prin1-to-string (nth 5 form))))
                      (if (eq (nth 5 form) 'step)
                          (setq step-size (prin1-to-string (nth 6 form))))))
                  )
                 ((eq (nth 3 form) 'downto)
                  (setq to 'downto)
                  (setq stop (prin1-to-string (nth 4 form)))
                  (if (and (eq (nth 5 form) nil) (&gt; (length form) 5))
                      (setq stop (concat stop &quot;()&quot;))
                    (if (string-match &quot;(&quot; (prin1-to-string (nth 5 form)))
                        (setq stop (concat stop (prin1-to-string (nth 5 form))))
                      (if (eq (nth 5 form) 'step)
                          (setq step-size (prin1-to-string (nth 6 form))))))
                  )
                 (t
                  ;;(debug &quot;Jean Michel Jarre: Oxygene III&quot;)))
                  ;;(debug &quot;Joaquin Rodrigo&quot;)
                  (setq start (prin1-to-string (nth 4 form)))
                  (cond
                   ((eq (nth 5 form) 'to)
                    (setq to 'to))
                   ((eq (nth 5 form) 'downto)
                    (setq to 'downto))
                   (t
                    (debug &quot;Dire Straits: Planet of New Orleans&quot;)))
                  (setq stop (prin1-to-string (nth 6 form)))
                  (if (eq (nth 7 form) 'step)
                      (progn
                        (setq step-size (and (nth 8 form) (prin1-to-string (nth 8 form))))
                        (assert (numberp (nth 8 form)))
                        )
                    )
                  )
                 )
                )
              ;;(debug &quot;Rod Stewart's Maggie May&quot;)
              (progn
                (setq var         variable)
                (setq start-2     (warn--cull-quotes (warn--splat-quest start)))
                (setq stop-2      (warn--cull-quotes (warn--splat-quest stop)))
                (setq step-size-2 (warn--splat-quest (and step-size (prin1-to-string step-size))))
                ) ;; end PROGN!
              ;; -----------------------------------------------------
              ;;(debug &quot;The Pretenders: Precious&quot;)
              (setq this_start     (concat this &quot;start&quot;))
              (setq this_stop      (concat this &quot;stop&quot;))
              (setq this_step      (concat this &quot;step&quot;))
              (setq this_step_size (concat this &quot;step_size&quot;))
              ;;(debug &quot;My Parties&quot;)
              (insert (concat (concat &quot;var &quot; T &quot; &quot; this_start &quot; = &quot; start-2 &quot;; &quot;)
                              (concat &quot;var &quot; T &quot; &quot; this_stop  &quot; = &quot; stop-2  &quot;; &quot;)
                              (if step-size
                                  (concat &quot;var &quot; T &quot; &quot; this_step &quot; = &quot; step-size-2 &quot;; &quot;
                                          &quot;var &quot; T &quot; &quot; this_step_size &quot; = &quot;
                                          (cond
                                           ((eq to 'to)
                                            (concat &quot;Math.abs(&quot; this_step &quot;)&quot;))
                                           ((eq to 'downto)
                                            (concat &quot;-Math.abs(&quot; this_step &quot;)&quot;))
                                           (t
                                            (debug &quot;Dire Straits: Heavy Fuel&quot;)))
                                          &quot;;\n&quot;)
                                (concat &quot;var &quot; T &quot; &quot; this_step_size &quot; = &quot;
                                        (cond
                                         ((eq to 'to)
                                          &quot;1&quot;)
                                         ((eq to 'downto)
                                          &quot;-1&quot;)
                                         (t
                                          (debug &quot;Dire Straits: Ticket to Heaven&quot;)))
                                        ) ;; end CONCAT!
                                )         ;; end if!
                              &quot;;\n&quot;)      ;; end CONCAT!
                      )                   ;; end INSERT!
              ;;(debug &quot;Rod Stewart: Hot Legs&quot;)
              (setq line 0)
              (setq p-prior
                    (save-excursion
                      (beginning-of-line)
                      (setq str (concat &quot;^ \t*//+ &quot; *pp-namespace* &quot; #location0-9&quot;
                                        &quot; (\\(&quot;       *drive-spec*   &quot;-a-zA-Z0-9_./+\\):\\(0-9+\\))&quot;))
                      (if (or (looking-at str) (re-search-backward str nil t))
                          (progn
                            ;;(debug &quot;Antonio Vivaldi&quot;)
                            (setq file (buffer-substring-no-properties           (match-beginning 1)
                                                                                 (match-end 1)))
                            (assert (stringp file))
                            (setq line (read-str (buffer-substring-no-properties (match-beginning 3)
                                                                                 (match-end 3))))
                            (assert (integerp line))
                            (point)
                            )
                        (setq file (concat *def-dir* *stump* &quot;.jtw&quot;))
                        (setq line 1)
                        (goto-char (point-min))
                        (forward-line 2)
                        (point)
                        )))
              (setq line (+ line (count-lines p-prior (point))))
              (decf line)
              (decf line)
              (insert (format &quot;// %s (setq file-stack '%s)\n&quot; *list-namespace* (prin1-to-string file-stack)))
              (insert (format &quot;// %s #location3 (%s:%d)\n&quot;    *pp-namespace*   file line))
              (insert (concat &quot;for (var &quot; T &quot; &quot; var &quot; = &quot; this_start &quot;;&quot;
                              &quot; ((&quot; this_step_size &quot; &gt; 0) ? &quot; var &quot; &lt;= &quot;
                              this_stop &quot; : &quot; var &quot; &gt;= &quot; this_stop &quot;); &quot;
                              var &quot; += &quot; this_step_size &quot;)&quot;))
              (if strobe (debug &quot;Pretenders: The Wait&quot;))
              ;;(debug &quot;Yehudi Menuhin&quot;)
              )))))
</pre></div>


<a name="A-bug-in-J_002eT_002eW_002e-superfor"></a>
<h3 class="section">2.2 A bug in J.T.W. superfor</h3>

<p>The question mark operator a ? b : c which expands to
</p>
<div class="example">
<pre class="example">Type result;
if (a) then
begin
&nbsp;&nbsp;&nbsp; result = b;
end
else
begin
&nbsp;&nbsp;&nbsp; result = c;
end
</pre></div>

<p>where type can be any Java type is not directly supported by the
arguments to the superfor macro in J.T.W.  Elsewhere the question mark
is supported.  Instead in the superfor macro you have to write the
following code to get a question mark operator online:
</p>
<div class="example">
<pre class="example">class SuperFor
begin
&nbsp;&nbsp;&nbsp; beginMain
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; foo(1,2);
&nbsp;&nbsp;&nbsp; endMain
&nbsp;&nbsp;&nbsp; function void foo(int x, int y)
&nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; superfor (var int i=0 to (x &lt; y QUEST 10 : 20))
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; begin
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.print(&quot; &quot; + i);
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; end
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.println();
&nbsp;&nbsp;&nbsp; end
end
</pre></div>


<p>where the symbol QUEST compiles into a question mark: ?.  When
built, the program prints out the following:
</p>
<div class="example">
<pre class="example">i=0
i=1
i=2
i=3
i=4
i=5
i=6
i=7
i=8
i=9
i=10
</pre></div>



<hr>
<div class="header">
<p>
Next: <a href="J_002eT_002eW_002e-Proof-of-concept-_00232-file-inclusion.html#J_002eT_002eW_002e-Proof-of-concept-_00232-file-inclusion" accesskey="n" rel="next">J.T.W. Proof of concept #2 file inclusion</a>, Previous: <a href="About-GNU-Java-Training-Wheels.html#About-GNU-Java-Training-Wheels" accesskey="p" rel="prev">About GNU Java Training Wheels</a>, Up: <a href="index.html#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html#Index" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
